# -*- coding: utf-8 -*-
"""M8_Ejercicio_de_preparación_de_datos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s8kHbBXTffXj0LT8CM0FX9BqTpwLlNOY

![picture](https://drive.google.com/uc?export=view&id=1e3nj5xVsTXcfjDxSPipCyZPQBSEp4lp-)

#<h1><font size = 6>Módulo 8: Ejercicio de preparación de datos en Python</font></h1>

<p><strong>Objetivo: </strong> El objetivo de este cuaderno es realizar todos los pasos dentro del proceso de preparación de datos sobre el conjunto de datos de Hotel Booking.</p>

En este módulo se va a trabajar con el conjunto de datos <b>Hotel Booking Demand</b>. El conjunto de datos contiene información sobre reservas de hotel realizadas en dos hoteles, uno en ciudad y otro un resort. Cada fila consiste en una reserva del hotel e incluye información sobre cuando fue realizada, la duración de la estadía, el número de adultos, niños y bebés entre otras cosas.

Este conjunto de datos es ideal para practicar el análisis exploratorio de los datos y los conceptos de limpieza y calidad de los datos.

En el siguiente enlace puede encontrar información sobre el conjunto de datos y la descripción de cada uno de los atributos:
<ul>
  <li>Descripción de los datos: <a href="https://www.kaggle.com/jessemostipak/hotel-booking-demand" target="_blank">https://www.kaggle.com/jessemostipak/hotel-booking-demand</a></li>
  <li>Es importante revisar primero el conjunto de datos y comprender algunos de los atributos</li>
  <li>Tipo de datos: csv</li>
</ul>

## <strong> Obtención de datos</strong>

En la siguiente línea se importan todas las librerías necesarias para el trabajo con el notebook:
"""

import pandas as pd
import matplotlib as plt
from matplotlib import pyplot
import seaborn as sns
import numpy as np
import folium
from folium.plugins import HeatMap
import plotly.express as px
from sklearn.neighbors import LocalOutlierFactor
from sklearn.preprocessing import MinMaxScaler
from sklearn.utils import resample

"""A continuación se importan los datos del CSV que se debe cargar en el Google Drive previamente:"""

# Leer datos desde archivo CSV
csv_path = "/content/drive/MyDrive/Colab Notebooks/hotel_bookings.csv"
df = pd.read_csv(csv_path)
# Imprimer las primeras cinco filas de un dataframe para probar que todo ok
df.head()

"""## <strong> Conociendo los datos</strong>

Para comenzar a conocer los datos se pueden utilizar dos métodos que nos ayudan a obtener un vistazo rápido del conjunto de datos, se utiliza el comando <code>dataframe.shape</code> y el comando <code>dataframe.info</code>:
"""

df.shape

df.info()

"""### Identificar los tipos de datos

Se exploran los tipos de datos de cada columna. Identifique si hay alguna que según su significado no coincida con su tipo de datos:
"""

#La función dtypes genera una tabla con el tipo de dato de cada columna
df.dtypes

"""### Identificar datos faltantes

Para identificar los datos faltantes en el conjunto de datos se puede utilizar la función <code>isnull</code> y sumar los valores:
"""

print(df.isnull().sum())

"""### Identificar datos atípicos

Para identificar datos atípicos se pueden utilizar distintos métodos. Utilicemos un gráfico de box plot para graficar una de las variables:
"""

fig = pyplot.figure(figsize=(8,8))
sns.boxplot(y=df["stays_in_weekend_nights"])
pyplot.show()

"""<div class="alert alert-success alertsuccess" style="margin-top: 20px">
   <strong>AHORA TÚ: </strong>  
  <p>
Seleccione otra variable numérica y pinte su gráfico de Boxplot, identifique si tiene valores atípicos o no.
</p>
</div>
"""

# Escribe tu código aquí y presiona Shift+Enter para ejecutar

"""Tambien se pueden analizar los datos utilizando alguna variable categórica, por ejemplo, las reservas que canceladas o no canceladas, y vicularlo a una variable numérica como las noches de fin de semana:"""

fig = pyplot.figure(figsize=(8,9))
sns.boxplot(x="is_canceled", y="stays_in_weekend_nights", data=df)

"""### Calcular las estadísticas

<p>Se va a utilizar la función <code>dataframe.describe</code> para visualizar las estadísticas del conjunto de datos: </p>
"""

df.describe()

df.describe(include=['object'])

"""### Análisis de tendencia central, posición y dispersión

El análisis de la tendencia central, la simetría y la dispersión de los datos es importante para entender cómo se comporta cada variable:
"""

#Variable tiempo de espera (número de días entre hecha la reserva y el día de llegada al hotel)
df['lead_time'].hist(figsize = (6,6))
pyplot.show

mean = df['lead_time'].mean()
median = df['lead_time'].median()
mode = df['lead_time'].mode()
skew = df['lead_time'].skew()
kurt = df['lead_time'].kurt()
print("La media es:", mean)
print("La mediana es:", median)
print("La moda es:", mode)
print("El sesgo es:", skew)
print("La kurtosis es:", kurt)

#Variable número de semana de llegada (la semana del año en la que llega el cliente)
df['arrival_date_week_number'].hist(figsize = (6,6))
pyplot.show

mean = df['arrival_date_week_number'].mean()
median = df['arrival_date_week_number'].median()
mode = df['arrival_date_week_number'].mode()
skew = df['arrival_date_week_number'].skew()
kurt = df['arrival_date_week_number'].kurt()
print("La media es:", mean)
print("La mediana es:", median)
print("La moda es:", mode)
print("El sesgo es:", skew)
print("La kurtosis es:", kurt)

"""<div class="alert alert-success alertsuccess" style="margin-top: 20px">
   <strong>AHORA TÚ: </strong>  
  <p>
Seleccione otra variable y analice su comportamiento
</p>
</div>
"""

# Escribe tu código aquí y presiona Shift+Enter para ejecutar

"""### Contando datos duplicados

Para ver los datos duplicados de todo el dataframe, simplemente llame al método <code>duplicated()</code>en el DataFrame. Si luego se llama al método SUM, se tendrá el total de duplicados:
"""

#Contando los duplicados de todo el dataframe
df.duplicated().sum()

"""## <strong> Exploración y visualización de los datos</strong>

Utilizando técnicas de visualización se puede comenzar a comprender el contexto alrededor de los datos. Se van a realizar diferentes preguntas capaces de brindar información interesante. Estas preguntas nos ayudan a encontrar análisis significativos sin siquiera aplicar alguna técnica de analítica. Se comprende mejor el mundo de las reservas de hoteles, así como las necesidades que les pueden surgir a las empresas y que se tratan de solucionar con herramientas analíticas.

### Análisis de variables numéricas

Primero se exploran las variables numéricas, y observamos su distribución. Se puede utilizar el diagrama de hist para visualizar todos los histogramas de las variables numéricas dentro del dataframe:
"""

df.hist(figsize=(20,15));

"""Tambien se puede analizar cada variable de manera independiente. En este gráfico se muestra el historigrama de la variable <b>arrival_date_week_number</b> que muestra las diferentes semanas del año 1 - 52 donde los clientes reservan o se hospendan en los hoteles:"""

df['arrival_date_week_number'].hist(figsize = (6,6))
pyplot.xlabel('arrival_date_week_number')
pyplot.ylabel('Cantidad')  
pyplot.title('Histograma arrival_date_week_number', fontweight ="bold")
pyplot.show

"""En este otro histograma se aprecia la distribución de la variable <b>adr</b> que significa la tarifa diaria promedio:"""

df['adr'].hist(figsize = (6,6))
pyplot.xlabel('Average Daily Rate')
pyplot.ylabel('Cantidad')  
pyplot.title('Histograma adr', fontweight ="bold")
pyplot.show

"""Para visualizar la relación entre dos variables numéricas se utiliza un gráfico de líneas. Este combina las variables de mes de llegada y tarifa promedio. Como tenemos variables que representan tiempo (años, meses, semanas, fecha) se puede realizar un análisis en el tiempo para ver su comportamiento. La temporada alta es Junio, Julio y Agosto y la temporada baja es Noviembre, Diciembre, Enero:"""

fig = pyplot.figure(figsize=(7,4),dpi=100)
pyplot.xticks(rotation=45,fontsize=10);
sns.lineplot(data=df, x= 'arrival_date_month', y = 'adr')

"""<div class="alert alert-success alertsuccess" style="margin-top: 20px">
   <strong>AHORA TÚ: </strong>  
  <p>
Ahora analiza el comportamiento de la variable <b>adr</b> pero con respecto a las semanas del año, ¿coincide con el gráfico anterior?
</p>
</div>
"""

# Escribe tu código aquí y presiona Shift+Enter para ejecutar

"""Haga doble clic <b>aquí</b> para ver la solución.

<!-- Respuesta:

fig = plt.figure(figsize=(10,5),dpi=100)
sns.lineplot(data=df, x= 'arrival_date_week_number', y = 'adr')
plt.xticks(rotation=45,fontsize=10);

-->

### Análisis de variables categóricas

Para analizar las variables categóricas, seleccione primero el subconjunto del dataframe y visualice  los valores de cada categoría. Identifique algún valor que no corresponda con el negocio:
"""

# Seleccionar las variables categóricas
df_cat = df.select_dtypes(include=['object'])
df_cat.head()

"""Visualizar los valores de cada una de las variables:"""

for col in df_cat.columns:
    print(f"{col}: \n{df_cat[col].unique()}\n")

"""Ahora, utilizando gráficos, se observa la proporción entre las distintas categorías:"""

# Variable si la reserva fue cancelada o no
sns.countplot(data=df, x = 'is_canceled')
pyplot.show()

# Inclinación de los clientes por los distintos tipos de habitación
sns.countplot(data=df, x = 'reserved_room_type')
pyplot.show()

# Por dónde ser realizaron las reservas
sns.countplot(data=df, x= 'market_segment')
pyplot.xticks(rotation=45,fontsize=10);

# Análisis de las reservas según el segmento del mercado

# Separamos los grupos por tipo de hotel y con solo las reservas no canceladas
rh = pd.DataFrame(df.loc[(df['hotel'] == 'Resort Hotel') & (df['is_canceled'] == 0)])
ch = pd.DataFrame(df.loc[(df['hotel'] == 'City Hotel') & (df['is_canceled'] == 0)])

# Ajuste tamaño de la figura
fig = pyplot.figure(figsize = (16, 9))

#Pie de Resort Hotel
ax = fig.add_subplot(121)
rh_segment_pie = pd.DataFrame(rh['market_segment'].value_counts())
ax.set_title('The Market Segment of Resort Hotel', fontsize = 14)
ax = pyplot.pie(x = rh_segment_pie['market_segment'], labels = rh_segment_pie.index, autopct = '%.3f%%')

#Pie de City Hotel
ax = fig.add_subplot(122)
ch_segment_pie = pd.DataFrame(ch['market_segment'].value_counts())
ax.set_title('The Market Segment of City Hotel', fontsize = 14)
ax = pyplot.pie(x = ch_segment_pie['market_segment'], labels = ch_segment_pie.index, autopct = '%.3f%%')

"""<div class="alert alert-success alertsuccess" style="margin-top: 20px">
   <strong>AHORA TÚ: </strong>  
  <p>
Visualiza la cantidad de Reservas asociadas al tipo de hotel, si es Resort o City, ¿Qué tipo de hotel tiene más reservas?
</p>
</div>
"""

# Escribe tu código aquí y presiona Shift+Enter para ejecutar

"""Haga doble clic <b>aquí</b> para ver la solución.

<!-- Respuesta:

sns.countplot(data=df, x = 'hotel')

Como podemos observar, hay casi el doble de reservas para el City Hotel que pare el Resort.

-->

### Combinando variables

Después de analizar las variables de manera individual para comprender su comportamiento, se pueden encontrar relaciones interesantes entres dos, tres o cuatro variables. A continuación se responden algunas preguntas interesantes:
"""

# ¿Qué tipo de hotel tiene el mayor número de cancelaciones?
sns.countplot(data=df, x = 'hotel', hue='is_canceled')
pyplot.show()

#¿Cuales son los paises más visitados?
paises_mas_visitas = df[df['is_canceled'] == 0]['country'].value_counts().reset_index()
paises_mas_visitas.columns = ['country', 'No of guests']
paises_mas_visitas

#Mapa para visualizar los paises anteriores y la cantidad de visitantes.
basemap = folium.Map()
guests_map = px.choropleth(paises_mas_visitas, locations = paises_mas_visitas['country'],color_continuous_scale="portland",
                           color = paises_mas_visitas['No of guests'], hover_name = paises_mas_visitas['country'])
guests_map.show()

# ¿Cuánto se paga por una noche de alojamiento?
# Filtrar las reservas no canceladas
cuanto_se_paga = df[df['is_canceled'] == 0] 
pyplot.figure(figsize=(12,8))
# Vamos a usar para este fin la variable 'adr', dividiendo por tipo de habitación y los dos tipos de hoteles (Average Daily Rate as defined by dividing the sum of all lodging transactions by the total number of staying nights)
sns.boxplot(x='reserved_room_type',y='adr',data=cuanto_se_paga,hue='hotel') # adr stands for prize of the room  
pyplot.title('Precio por tipo de hab por noche', fontsize=16)
pyplot.xlabel('Tipo de Habitación')
pyplot.ylabel('Precio en [EUR]' )
pyplot.show()

# ¿Existe alguna relación entre el número de días transcurridos desde la reserva, y las cancelaciones?
# lead_time: num días transcurridos entre la fecha de reserva y el dia de llegada. ANTICIPACIÓN DE LA RESERVA.
pyplot.figure(figsize=(12,6))
sns.barplot(x='arrival_date_year', y='lead_time',hue='is_canceled', data= df)
pyplot.title('Año de llegada, Anticipo y Cancelaciones')

# ¿Se distribuyen de forma homogénea las llegadas dependiendo del mes?
pyplot.figure(figsize=(15,6))
sns.countplot(data = df, x = 'arrival_date_day_of_month', hue='hotel')
pyplot.show()

"""Se concluye que se distribuyen de forma razonablemente homogenea. El valor más bajo se registra los días 31, esto se debe a que no todos los meses tienen 31 días y por tanto el recuento de llegadas es inferior."""

#  ¿Qué tipo de régimen de pensión eligen los huéspedes?
# BB: BED AND BREAKFAST
# HB: Half board
# SC: No meal
# FB: FULL BOARD (PENSIÓN COMPLETA)
meal_labels= ['BB','HB', 'SC', 'Sin definir', 'FB']
size = df['meal'].value_counts()
pyplot.figure(figsize=(8,8))
cmap =pyplot.get_cmap("Pastel2")
colors = cmap(np.arange(6)*1)
my_circle=pyplot.Circle( (0,0), 0.7, color='white')
pyplot.pie(size, labels=meal_labels, colors=colors, wedgeprops = { 'linewidth' : 3, 'edgecolor' : 'white' })
p=pyplot.gcf()
p.gca().add_artist(my_circle)
pyplot.title('Tipo de régimen', weight='bold')
pyplot.show()

"""La mayoria de las reservas son con régimen de Bed & Breakfast y sólo una parte muy pequeña elije pensión completa.  Como podemos observar en el gráfico de abajo, la gran mayoría de reservas son con régimen de Bed & Breakfast. Casi nadie elige Full Board

Si puede analizar el comportamiento de un país en específico, utilicemos España como ejemplo:
"""

# Cantidad de reservas en España
reservation_date_Spain = df[df['country'] == "ESP"][df['is_canceled'] == 0]['arrival_date_year'].value_counts().reset_index()
reservation_date_Spain.columns = ['Año', 'Nº Reservas']
reservation_date_Spain

# Se visualizan los resultados
sns.barplot(x = "Año", y= "Nº Reservas", data = reservation_date_Spain)

# ¿Cuál es el país con más hoteles y de cual tipo?
counts = df['country'].value_counts()
pyplot.subplots(figsize=(7,5))
sns.countplot(x='country', hue='hotel',  data=df[df['country'].isin(counts[counts > 2000].index)])
pyplot.show()

# Analice la relación entre la variable “Deposit type” y las cancelaciones
# group data for deposit_type:
deposit_cancel_data = df.groupby("deposit_type")["is_canceled"].describe()

#show figure:
pyplot.figure(figsize=(8, 6))
sns.barplot(x=deposit_cancel_data.index, y=deposit_cancel_data["mean"] * 100)
pyplot.title("Influencia del depósito en la cancelación", fontsize=16)
pyplot.xlabel("Tipo de depósito", fontsize=16)
pyplot.ylabel("Cancelaciones [%]", fontsize=16)
pyplot.show()

"""<div class="alert alert-success alertsuccess" style="margin-top: 20px">
   <strong>AHORA TÚ: </strong>  
  <p>
Si quisieramos saber si se tienen un mayor índice de cancelación los fines de semana o entre semana. ¿Qué tipo de análisis sería necesario hacer? ¿Qué graficos nos ayudaría a mostrar esos datos?
</p>
</div>
"""

# Escribe tu código aquí y presiona Shift+Enter para ejecutar

"""Haga doble clic <b>aquí</b> para ver la solución.

<!-- Respuesta:

plt.figure(figsize=(15, 8))
plt.subplot(1, 2, 2)
sns.countplot(data = df, x = 'stays_in_weekend_nights', hue='is_canceled')
plt.title('Número de noches en fin de semana', size=11)
plt.subplots_adjust(right=2)
plt.show()

Como podemos observar, la mayoría de las reservas para fin de semana no se han cancelado.

-->

<div class="alert alert-success alertsuccess" style="margin-top: 20px">
   <strong>AHORA TÚ: </strong>  
  <p>
Visualice la cantidad de reservas ordenadas por país en un gráfico de barras
</p>
</div>
"""

# Escribe tu código aquí y presiona Shift+Enter para ejecutar

"""Haga doble clic <b>aquí</b> para ver la solución.

<!-- Respuesta:

fig = plt.figure(figsize=(12,4), dpi=150)


country_wise_guests = df[(df['is_canceled'] == 0)]['country'].value_counts().reset_index()
country_wise_guests.columns = ['country', 'No of guests']

country_wise_guests = country_wise_guests[country_wise_guests['No of guests'] > 60]

sns.barplot(data=country_wise_guests, x = 'country', y = 'No of guests')
plt.xticks(rotation=90,fontsize=11);

-->

De este Análisis Exploratorio de los datos se puede concluir lo siguiente:

La indudable importancia de la variable hotel, referida al tipo de hotel que se está reservando, pues como hemos podido ver en varios gráficos, la diferencia en la interpretación es considerable cuando hablamos de un resort frente a cuando hablamos de un hotel de ciudad.
Por otro lado, las peculiaridades en ciertas variables como “lead_time”, “Booking_changes” y “previous_cancellations”, las cuales se considera que pueden tener un peso considerable para predecir de una manera más precisa futuras cancelaciones.

## <strong> Limpieza de datos</strong>

### Resolver problema de datos faltantes

El problema de los datos faltantes en este conjunto no es tan complicado. Observemos cuáles variables tienen datos faltantes y qué se puede hacer en cada caso:
"""

print(df.isnull().sum())

df[["children","country","agent","company"]].describe(include="all")

"""La cantidad de datos faltantes en la columna <b>company</b> hace que no sea útil sustituirlos o imputarlos, pues faltan muchos datos y modificarlos supondría una grave alteración de los datos.

La columna <b>agent</b> no está en la misma situación pero no aporta gran valor pues solo es el identificador de los agentes, no el nombre en si.

Por tanto se procede a eliminar esas variables:
"""

df = df.drop(['company', 'agent'], axis=1)

"""Para trabajar las columnas <b>country</b> y <b>children</b> una alternativa es eliminar los registros que tienen NA:"""

df1 = df.dropna(subset=['country', 'children'], axis=0)

print(df1.isnull().sum())

"""Otra alternativa es sustituir la variable con un valor.

Para la columna <b>country</b> que es categórica sería sustituir con la Moda.

Para la variable <b>children</b> que es numérica sería necesario analizar su simetría y luego sustituir con media o mediana:
"""

# El país más común es PRT
df["country"].replace(np.nan, "PRT", inplace=True)

sns.displot(df["children"])

mean = df['children'].mean()
median = df['children'].median()
mode = df['children'].mode()
skew = df['children'].skew()
kurt = df['children'].kurt()
print("La media es:", mean)
print("La mediana es:", median)
print("La moda es:", mode)
print("El sesgo es:", skew)
print("La kurtosis es:", kurt)

df["children"].replace(np.nan, 0, inplace=True)

print(df.isnull().sum())

"""### Tipos de datos

Una vez resuelto el problema de los datos faltantes para la columna <b>children</b> se cambia el tipo de datos de la columna a Int y para la columna <b>reservation_status_date</b> cambiarla a DateTime:
"""

df[["children"]] = df[["children"]].astype("int")

df['reservation_status_date'] = pd.to_datetime(df['reservation_status_date'])

df.dtypes

"""### Datos inconsistentes

Al analizar las características de las reservas, en concreto en lo que se refiere a los huéspedes, se puede observar que existen registros que cumplen con la condición de que: (dataframe.children == 0) & (dataframe.adults == 0) & (dataframe.babies == 0)

No puede haber 0's en una misma observación en adults, children y babies (pues no se puede hacer una reserva sin huéspedes).

Estos registros se deben eliminar:
"""

filter = (df.children == 0) & (df.adults == 0) & (df.babies == 0)
sum(filter)

"""Se concluye que se trata de un error, por lo que se procede a eliminarlos:"""

df = df[~filter]
df.shape

"""Comprobación de que no hay registros que sumen cero y por tanto el número de registros total es correcto:"""

# TOTAL DE HUÉSPEDES

df['Total_Guests'] = df['adults'] + df['children']

# No hay ningún registro que sume 0

filter = df.Total_Guests != 0
df.drop("Total_Guests", axis=1, inplace=True) # Elimino la columna porque solo era para probar
sum(filter) # el número de registros total son 119210, asi que es correcto

"""### Datos atípicos

Se comienza con la detección de outliers visualizando los boxplot de las diferentes variables que conforman nuestro conjunto. De su visualización se obtiene un total de 8 variables que presentan cierta problemática: 'lead time', 'stays in weekend nights', 'stays in week nights', 'adults', 'babies', 'required car parking spaces', 'adr', 'previous cancellations'.
"""

columnas = ['lead_time', 'stays_in_weekend_nights', 'stays_in_week_nights', 'adults', 
           'babies', 'required_car_parking_spaces', 'adr', 'previous_cancellations']
n = 1
pyplot.figure(figsize=(20,15))

for column in columnas:
  pyplot.subplot(4,4,n)
  n = n+2
  sns.boxplot(y=df[column])
  pyplot.tight_layout()

"""Se procede a sustituir la mayoría de los valores atípicos por otros dentro del último cuartil o por el valor cero dependiendo del caso."""

df.loc[df.lead_time > 400, 'lead_time'] = 400
df.loc[df.stays_in_weekend_nights >=  5, 'stays_in_weekend_nights'] = 5
df.loc[df.stays_in_week_nights > 20, 'stays_in_week_nights'] = 20
df.loc[df.adults > 10, 'adults'] = 10
df.loc[df.babies > 8, 'babies'] = 0
df.loc[df.required_car_parking_spaces > 5, 'required_car_parking_spaces'] = 0
df.loc[df.adr > 1000, 'adr'] = 1000
df.loc[df.adr < 30, 'adr'] = 0

"""<p>Cuando se quiere analizar todas las variables para saber si hay registros atípicos e inconsistentes entre ellas, se puede utilizar el algoritmo de LOF.</p>
<p>Para el ejemplo se utiliza una selección de las variables numéricas</p>
"""

#Seleccionar columnas
select_df = df[['lead_time','arrival_date_year','stays_in_weekend_nights', 'adults','is_repeated_guest','previous_cancellations','required_car_parking_spaces', 'adr']]

#Especificar el modelo que se va a utilizar
model = LocalOutlierFactor(n_neighbors = 30)

#Ajuste al modelo
y_pred = model.fit_predict(select_df)
y_pred

#Filtrar los indices de los outliers
outlier_index = (y_pred == -1) #los valores negativos son outliers

#Filtrar los valores de los outliers en el dataframe
outlier_values = select_df.iloc[outlier_index]
outlier_values

"""### Datos redundantes

Para identificar los atributos redundantes se puede utilizar la matriz de correlación e indentificar correlaciones entre atributos. La matriz de correlación solo se calcula sobre atributos numéricos:
"""

pyplot.figure(figsize = (24, 12))
corr = df.corr()
sns.heatmap(corr, annot = True, linewidths = 1)
pyplot.show()

"""### Datos duplicados

El análisis de datos duplicados en este conjunto es interesante. Existen muchas filas duplicadas, sin embargo en algunos casos pudieran ser coincidencias de reservas iguales, para clientes diferentes. En este caso es mejor indagar un poco en el negocio para saber cuál es realmente la posibilidad de reservas idénticas. Como último recurso, si se eliminan todos los duplicados, igual quedan suficientes datos para realizar un análisis interesante:
"""

#Contando los duplicados de todo el dataframe
df.duplicated().sum()

# Permite ver las filas duplicadas de todo el dataframe
df.loc[df.duplicated(), :]

# Si se quisiera eliminar los duplicados
df_drop = df.drop_duplicates()
df_drop.shape

"""## <strong> Transformaciones a los datos</strong>

Las transformaciones que se van a aplicar a continuación dependen de la técnica analítica a aplicar. No siempre es necesario aplicarlas todas. En este notebook se aplicarán todas a manera de ejemplo. Es importante tener claras las necesidades de cada técnica para aplicar lo más adecuado:

### Normalización
La normalización o escalamiento es necesaria para poner todas las variables numéricas en la misma escala. Las técnicas basadas en distancias siempre necesitan Normalización. A continuación se normalizan las variales numéricas:
"""

df_normalize = df.copy()

scaler = MinMaxScaler()
df_normalize[['lead_time','arrival_date_year','arrival_date_day_of_month','stays_in_weekend_nights','stays_in_week_nights','adr']] = scaler.fit_transform(
    df_normalize[['lead_time','arrival_date_year','arrival_date_day_of_month','stays_in_weekend_nights','stays_in_week_nights','adr']])
df_normalize[['lead_time','arrival_date_year','arrival_date_day_of_month','stays_in_weekend_nights','stays_in_week_nights','adr']].tail(10)

"""### Discretización

Para realizar un ejemplo de discretización se utiliza la variable <b>lead_time</b> que significa los días de antelación con la que se realiza una reserva. Primero se visualiza la distribución de la variable:
"""

fig = pyplot.figure(figsize=(8,8))
sns.boxplot(y=df["lead_time"])
pyplot.show()

"""A continuación se diseñan los grupos (bins) por los cuales se desea discretizar la variable y se realiza la discretización:"""

nivelAntelacion = ['Ninguno', '2-3Semanas', '1Mes','2Meses','3Meses','Mas3Meses']

df['lead_time_binned']=pd.cut(x = df['lead_time'],
                        bins = [0,1,21,30,60,120,737], 
                        labels = nivelAntelacion, include_lowest=True)
df[['lead_time','lead_time_binned']].head(10)

"""Una vez discretizada la variable se visualizan los resultados, se puede observar que la mayor proporsión de ejemplos permanecen en la categorías de Mas3Meses. Tambien se analiza cómo se comportan las cancelaciones con respecto a la nueva variable:"""

sns.catplot(x="lead_time_binned", kind="count", data=df, height = 6, aspect = 1.5)
pyplot.show()

sns.catplot(x="lead_time_binned", hue ='is_canceled' ,kind="count", data=df, height = 6, aspect = 1.5)
pyplot.show()

"""### Numerización

El objetivo de numerizar es convertir a número distintas variables que son categóricas, esto puede ser necesario para ciertas técnicas que solo funcionan con datos numéricos. A continuación se muestra cómo numerizar distintas variables del conjunto de datos según su tipo y valor:

Las siguientes variables se pueden numerizar 1 a 1, esto significa que se puede sustituir los valores por números:
"""

# Numerizar 1 a 1
df_cat['hotel'] = df_cat['hotel'].map({'Resort Hotel' : 0, 'City Hotel' : 1})
df_cat['reserved_room_type'] = df_cat['reserved_room_type'].map({'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6,'H': 7, 'L': 8})
df_cat.head()

"""Observe y analice los valores de la variable <b>meal</b>:
*   SC: No meal
*   BB: BED AND BREAKFAST
*   HB: Half board
*   FB: FULL BOARD (PENSIÓN COMPLETA)
*   Undefined: No definido el régimen de comida

Si no estuviera la categoría de Undefined, se pusiera numerizar 1 a 1, pero al existir, no es posible. Se puedieran eliminar esos registros o tratarlos como datos faltantes, si son pocos.

Observe y analice la variable <b>market_segment</b>:
*   Direct
*   Corporate
*   Online Travel Agents
*   Offline Travel Agents/Tours Operators
*   Complementary
*   Groups
*   Undefined
*   Aviontion

<p>¿Pueden determinar un orden natural en los datos? No se puede. Numerizar de esta forma sería un error:</p>
`cat_df['market_segment'] = cat_df['market_segment'].map({'Direct': 0, 'Corporate': 1, 'Online TA': 2, 'Offline TA/TO': 3, 'Complementary': 4, 'Groups': 5, 'Undefined': 6, 'Aviation': 7})`

Para las siguientes variables no se puede realizar el mismo proceso, pues son variables Nominales, no tienen un orden natural, y numerizarlas 1 a 1 sería introducir un error grave en los datos y en las salidas de cualquier algoritmo. Hay que numerizar de 1 a N, creando variable dummies:
"""

df_cat = pd.get_dummies(df_cat, columns = ["distribution_channel"])
df_cat = pd.get_dummies(df_cat, columns = ["customer_type"])
df_cat = pd.get_dummies(df_cat, columns = ["deposit_type"])
df_cat.head()

"""### <strong>Técnicas de muestreo</strong>

Si el objetivo fuera predecir la variable <b>is_canceled</b> se debería analizar el balance de cada una de las clases, a continuación se muestran en un gráficos:
"""

# Variable si la reserva fue cancelada o no
sns.countplot(data=df, x = 'is_canceled')
pyplot.show()

"""Es evidente que hay más datos de una que de la otra, pudiera aplicarse una técnicas de submuestreo para balancear las clases:"""

# Contar las clases
count_class_No, count_class_Yes = df["is_canceled"].value_counts()
# Dividir los dataframes por las clases
df_class_No = df[df["is_canceled"] == 0]
df_class_Yes = df[df["is_canceled"] == 1]
# submuestrear la clase mayoritaria No
no_downsampled = resample(df_class_No,
                          replace=False, # sample without replacement
                          n_samples=count_class_Yes, # Number of samples to generate.
                          random_state=27) # reproducible results
                          # combinar dataframes
df_sample = pd.concat([df_class_Yes, no_downsampled])

sns.countplot(data=df_sample, x = 'is_canceled')
pyplot.show()

"""<h1><font size = 6>¡Haz terminado el curso! ¡Felicitaciones!</font></h1>
<h1><font size = 6>Si te gustó recomiéndalo con tus amigos</font></h1>
"""
